----------------mysql查询 --------------------------------------
mysql = server层（连接器，分析器。。。）  + 存储引擎

连接器  用户认证  tcp握手 建立连接，读取权限   注意：一个用户成功建立连接后，即使用管理员账号对这个账号的权限做了修改，也不会影响到已有的权限，新建立的权限才会用到新的权限设置
show processlist  sleep行
--------------

+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
| Id | User            | Host      | db   | Command | Time  | State                  | Info             |
+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
|  5 | event_scheduler | localhost | NULL | Daemon  | 26106 | Waiting on empty queue | NULL             |
|  8 | root            | localhost | NULL | Sleep   | 25968 |                        | NULL             |
|  9 | root            | localhost | NULL | Query   |     0 | init                   | show processlist |
+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
3 rows in set (0.01 sec)

如何解决长链接时间过长导致mysql内存大？
1.定期断开长链接
2. 执行一个大的操作后，mysql5.7后执行mysql_reset_connection 初始化连接资源（不会重连 跟 重新做权限验证）

查询缓存
不建议使用查询缓存：
对于更新频繁的表，缓存失效非常频繁，只要有一个表更新，所有表的缓存都会清空。不经常更新的静态业务表，如系统配置表，可以使用缓存
注意 mysql8.0直接将查询缓存整个功能删掉了
之前的版本  通过query_cache_type=DEMMAND 按需使用缓存,默认sql都不适用缓存，显示指定 select SQL_CACHE显示指定

分析器：
    词法分析  select update delete ?
    语法分析 you hanve an error in you SQL syntax  /  column不存在 
    

优化器
   判断多个索引的时候使用哪个索引
   多个表关联的时候，怎么决定关联表的顺序
   。。。

执行器
  判断有没有该表的权限
  根据表的引擎定义，使用这个引擎提供的接口获取数据
  
  
-----------------------mysql 更新 -----------------------------
redo log  innodb特有；  物理日志 记录的是在某个数据页上做了什么修改；循环写,空间固定，会用完
binlog  Server层的日志 所有引擎可以使用；逻辑日志，记录的是这个语句的原始逻辑 ；可以追加写入的，binlog文件写到一定大小会切换到下一个，并不会覆盖以前的日志。

WAL  write-ahead-logging  先写日志，再写磁盘 ； 如果每次更新都要查询磁盘 更新磁盘，IO成本会很高 
更新一条记录的时候，innodb先把记录写到redo log,并且更新内存 然后innodb会在适当的时候，将这个操作记录更新到磁盘里面
redo log , write pos      checkpoint 
有了redo log ,innodb可以保证数据库发生异常，之前提交的记录不会丢失  crash-safe

更新一条数据 先写redo log  prepare状态 ---->写binlog ------> 提交事务 redo log commit 状态
   两阶段提交  为了让两份日志的逻辑保持一致
恢复数据库或者增加备库   全量DB备份 + binlog 实现

innodb_flush_log_at_trx_commit 建议设置为1，保证每次事务的redo log都持久化到磁盘，以保证mysql异常重启后数据不会丢失。
sync_binlog 建议也设置成1，保证每次事务的binlog都持久化到磁盘,保证mysql异常重启后，binlog不会丢失。
----------------------------------------------------------------
事务的隔离级别：
1.读未提交  一个事务还没提交，它做的变更就可以被其他的事务看到
2.读提交： 一个事务提交之后，它做的变更才可以被其他事务看到
3.可重复读： 一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据是一致的。未提交变更对于其他事务也是不可见
4.串行化: 同一行记录，写加写锁，读加读锁，读写锁冲突，后访问的事务必须等前一个事务执行完成，才可以继续执行

oracle 默认的隔离级别  读提交  oracle ---> mysql 一定也设置成读提交  transaction-isolation=READ-COMMITED
隔离级别越高，效率越低

不建议使用长事务 事务提交之前，数据库里面可能用到的回滚记录都要保留，会导致占用大量的空间

误用长事务  set autocommit = 0 
避免使用长事务  显式启动事务语句  set autocommit = 1, 启动事务  begin /start transaction |  commit or rollback 提交事务  or 回滚事务 |  commit work and chain 提交事务并启动下一个事务，省去了begin

查询事务的表 information_schema.INNODB_TRX    
---------------------------------------------------------------
索引 不使用2叉树的原因，尽可能少的访问磁盘，改用N叉树

InnoDB 使用了B+树索引模型，所有的数据都是存储在B+树中的， 每一个索引对应一棵 B+树

根据叶子结点的类型 索引分为
1. 主键索引 叶子结点存放的是整行数据（page ,一个page 含有多个行，通过二分查找确定指定的行），又称为聚簇索引 clustered index
2. 非主键索引 叶子结点内容是主键的值， 非主键索引又被成为二级索引

查询的区别：
非主键索引的查询需要多扫描一颗索引树（回表 k索引树----->得到主键ID----->主键ID索引树），应用中尽量使用主键索引

B+树 为了维护索引的有序性，在插入新值的时候需要做必要的维护

主键长度越小，普通索引的叶子结点就越小，普通索引占用的空间也就越小
自增主键每次插入一条新记录，都是追加操作，不涉及挪动其他记录，也不会触发叶子结点的分裂。
所以建议用自增主键作为索引

适合用业务字段直接做主键的场景？ 只有一个索引，该索引必须是唯一索引  KV场景

-----------------------------------------------------------
回到主键索引树搜索的过程称为回表
select * from T where k between 3 and 5 查询结果所需要的数据只在主键索引上游，所以

select ID from T where k between 3 and 5  ID的值已经在k索引树，可以直接提供查询结果，不需要回表，索引k已经覆盖了我们的查询需求，称为覆盖索引
通过覆盖索引可以减少树的搜索次数，显著提高查询性能，是一个常用的性能优化手段
索引字段的维护是有代价的，在建立冗余索引来支持覆盖索引是需要权衡考虑 （比如需要高频通过身份证号 查询他的姓名，可以通过 身份证号+姓名建立联合索引  使用覆盖索引不需要回表查询整行记录）

最左前缀原则
B+树索引结构 可以利用索引的最左前缀来定位记录 
最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符
不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索  （由于索引项是按照索引定义里面出现的字段顺序排序的，查到第一个符合条件的记录，然后向后遍历，直到不满足条件为止）

建立联合索引的时候，如何安排索引内的字段顺序？
评估的标准：索引的复用能力。
通过调整一个顺序，可以少维护一个索引，那么这个顺序往往需要优先考虑的采用的

有(a,b) 联合索引，一般不需要单独为a 建立索引

既有基于(a,b) 又有基于a,b各自的查询，由于基于b无法使用(a,b)这个联合索引，需要额外维护另外一个索引(b), 即需要同时维护（a,b）(b)两个索引 ，这个时候考虑空间，name字段大于age ，需要创建(name,age) (age)

create table `t_user`(
    id int(11) not null,
    id_card varchar(32) default null,
    name varchar(32) default null,
    age int(11) default null,
    ismale tinyint(1) default null,
    primary key(id),
    key id_card (id_card),
    key name_age(name,age),
) engine=InnoDB

索引下推
select * from t_user where name like "张%" and age = 10 and ismale = 1;
MySQL 5.6前 只能从第一个满足 张%的记录开始一个回表，到主键索引上找出数据行，再对比字段值（判断age = 10 ismale = 1）
MySQL 5.6后引入索引下推优化，在遍历索引的过程中，对索引中包含的字段先做判断（age = 10）,直接过滤掉不满足条件的记录，减少回表次数。

为什么需要重建索引？
索引由于删除或者页分裂的原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按照顺序插入，这样页面的利用率更高，索引更紧凑，更省空间。
如何重建索引？
alter table T engine = InnoDB

习题：
create table geek(
    a int(11) not null,
    b int(11) not null,
    c int(11) not null,
    d int(11) not null,
    primary key(a,b),
    key c (c),
    key ca(c,a),
    key cb(c,b)
)engine=InnoDB
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
对于 ca 联合索引可以去掉
对于 cb 联合索引可以保留
对于二级索引c,会默认跟主键做联合索引，索引c的排序为cab,索引cb的排序为cba, ca可以去掉，cb可以保留
---------------------全局锁 跟 表锁-----------------------------
表的初衷：处理并发问题

根据加锁的范围分为：  
全局锁
    对真个数据库实例加锁
    flush tables with read lock  整个库处理只读状态，更新，定义，更新类事务都会阻塞
    使用场景：全库逻辑备份
    危险： 业务停止；主从延迟
    mysqldump --single-transaction 导数据前会启动一个事务，确保拿到一致性视图(可重复读)  只适用于所有的表使用事务引擎（innoDB）的库， MyISam只能使用 flush tables with read lock
    
    set global readonly=true 同样可以实现全库只读，但是不建议使用
         有些系统中 readonly 可能用作其他逻辑，用来判断一个库是主库还是备库，修改global变量影响面很大，不建议使用
         异常处理机制有差异，flush tables with read lock 执行后如果客户端异常断开，mysql自动会释放这个全局锁，整个库回到正常更新的状态；而readonly=true后，客户端发生异常，数据库就会一直保持readonly状态，导致整个库长时间处于不可写状态，风险较高
表级锁
   表锁 lock tables read /write |  unlock tables  除了限制别的线程读写外，也限定了本线程接下来的操作对象  InnoDB这种支持行锁的引擎，一般不适用lock tables, 影响面太大
   元数据锁  meta data lock  MDL不需要显示使用，保证读写的正确性  MYSQL5.5版本后，对一个表增删改查的时候，自动加MDL读锁；对表结构变更的时候，加MDL写锁

   事务中的MDL锁，在语句执行开始时候申请，语句结束后并不会马上释放，要等事务提交后才可以释放；如果不注意给一个小表加字段，可能导致表挂掉
   如何安全的给一个小表加字段：
       1.解决长事务，事务不提交，一直占用MDL锁，做DDL变更如果有长事务在执行这个表，要先暂停DDL或者kill掉长事务 

   对于请求很频繁的热点表，如何安全的加字段？
   alter table 设置等待时间，如果等待时间拿到MDL写锁最好，拿不到不要阻塞后面的业务语句，先放弃。
   
   
行锁









