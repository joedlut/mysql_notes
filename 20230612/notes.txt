----------------mysql查询 --------------------------------------
mysql = server层（连接器，分析器。。。）  + 存储引擎

连接器  用户认证  tcp握手 建立连接，读取权限   注意：一个用户成功建立连接后，即使用管理员账号对这个账号的权限做了修改，也不会影响到已有的权限，新建立的权限才会用到新的权限设置
show processlist  sleep行
--------------

+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
| Id | User            | Host      | db   | Command | Time  | State                  | Info             |
+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
|  5 | event_scheduler | localhost | NULL | Daemon  | 26106 | Waiting on empty queue | NULL             |
|  8 | root            | localhost | NULL | Sleep   | 25968 |                        | NULL             |
|  9 | root            | localhost | NULL | Query   |     0 | init                   | show processlist |
+----+-----------------+-----------+------+---------+-------+------------------------+------------------+
3 rows in set (0.01 sec)

如何解决长链接时间过长导致mysql内存大？
1.定期断开长链接
2. 执行一个大的操作后，mysql5.7后执行mysql_reset_connection 初始化连接资源（不会重连 跟 重新做权限验证）

查询缓存
不建议使用查询缓存：
对于更新频繁的表，缓存失效非常频繁，只要有一个表更新，所有表的缓存都会清空。不经常更新的静态业务表，如系统配置表，可以使用缓存
注意 mysql8.0直接将查询缓存整个功能删掉了
之前的版本  通过query_cache_type=DEMMAND 按需使用缓存,默认sql都不适用缓存，显示指定 select SQL_CACHE显示指定

分析器：
    词法分析  select update delete ?
    语法分析 you hanve an error in you SQL syntax  /  column不存在 
    

优化器
   判断多个索引的时候使用哪个索引
   多个表关联的时候，怎么决定关联表的顺序
   。。。

执行器
  判断有没有该表的权限
  根据表的引擎定义，使用这个引擎提供的接口获取数据
  
  
-----------------------mysql 更新 -----------------------------
redo log  innodb特有；  物理日志 记录的是在某个数据页上做了什么修改；循环写,空间固定，会用完
binlog  Server层的日志 所有引擎可以使用；逻辑日志，记录的是这个语句的原始逻辑 ；可以追加写入的，binlog文件写到一定大小会切换到下一个，并不会覆盖以前的日志。

WAL  write-ahead-logging  先写日志，再写磁盘 ； 如果每次更新都要查询磁盘 更新磁盘，IO成本会很高 
更新一条记录的时候，innodb先把记录写到redo log,并且更新内存 然后innodb会在适当的时候，将这个操作记录更新到磁盘里面
redo log , write pos      checkpoint 
有了redo log ,innodb可以保证数据库发生异常，之前提交的记录不会丢失  crash-safe

更新一条数据 先写redo log  prepare状态 ---->写binlog ------> 提交事务 redo log commit 状态
   两阶段提交  为了让两份日志的逻辑保持一致
恢复数据库或者增加备库   全量DB备份 + binlog 实现

innodb_flush_log_at_trx_commit 建议设置为1，保证每次事务的redo log都持久化到磁盘，以保证mysql异常重启后数据不会丢失。
sync_binlog 建议也设置成1，保证每次事务的binlog都持久化到磁盘,保证mysql异常重启后，binlog不会丢失。
----------------------------------------------------------------
事务的隔离级别：
1.读未提交  一个事务还没提交，它做的变更就可以被其他的事务看到
2.读提交： 一个事务提交之后，它做的变更才可以被其他事务看到
3.可重复读： 一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据是一致的。未提交变更对于其他事务也是不可见
4.串行化: 同一行记录，写加写锁，读加读锁，读写锁冲突，后访问的事务必须等前一个事务执行完成，才可以继续执行

oracle 默认的隔离级别  读提交  oracle ---> mysql 一定也设置成读提交  transaction-isolation=READ-COMMITED
隔离级别越高，效率越低

不建议使用长事务 事务提交之前，数据库里面可能用到的回滚记录都要保留，会导致占用大量的空间

误用长事务  set autocommit = 0 
避免使用长事务  显式启动事务语句  set autocommit = 1, 启动事务  begin /start transaction |  commit or rollback 提交事务  or 回滚事务 |  commit work and chain 提交事务并启动下一个事务，省去了begin

查询事务的表 information_schema.INNODB_TRX    








